# -*- coding: utf-8 -*-
"""Krishna AQI code.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1iP1wtyXBBK0Jr7p-9FjGOTGArRxlFa_8
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.neighbors import KNeighborsClassifier
from sklearn.ensemble import GradientBoostingClassifier
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix

# Load the data
df = pd.read_csv('city_day.csv', parse_dates=["Date"])

# Get only numeric columns
numeric_columns = df.select_dtypes(include=np.number).columns

# Fill missing values with mean based on City for numeric columns
df[numeric_columns] = df.groupby("City")[numeric_columns].transform(lambda x: x.fillna(x.mean()))


# Calculate sub-indexes for pollutants
def get_PM10_subindex(x):
    if x <= 50:
        return x
    elif 50 < x <= 100:
        return x
    elif 100 < x <= 250:
        return 100 + (x - 100) * 100 / 150
    elif 250 < x <= 350:
        return 200 + (x - 250)
    elif 350 < x <= 430:
        return 300 + (x - 350) * 100 / 80
    elif x > 430:
        return 400 + (x - 430) * 100 / 80
    else:
        return 0

def get_PM25_subindex(x):
    if x <= 30:
        return x * 50 / 30
    elif 30 < x <= 60:
        return 50 + (x - 30) * 50 / 30
    elif 60 < x <= 90:
        return 100 + (x - 60) * 100 / 30
    elif 90 < x <= 120:
        return 200 + (x - 90) * 100 / 30
    elif 120 < x <= 250:
        return 300 + (x - 120) * 100 / 130
    elif x > 250:
        return 400 + (x - 250) * 100 / 130
    else:
        return 0

def get_SO2_subindex(x):
    if x <= 40:
        return x * 50 / 40
    elif 40 < x <= 80:
        return 50 + (x - 40) * 50 / 40
    elif 80 < x <= 380:
        return 100 + (x - 80) * 100 / 300
    elif 380 < x <= 800:
        return 200 + (x - 380) * 100 / 420
    elif 800 < x <= 1600:
        return 300 + (x - 800) * 100 / 800
    elif x > 1600:
        return 400 + (x - 1600) * 100 / 800
    else:
        return 0

df["PM10_SubIndex"] = df["PM10"].apply(get_PM10_subindex)
df["PM2.5_SubIndex"] = df["PM2.5"].apply(get_PM25_subindex)
df["SO2_SubIndex"] = df["SO2"].apply(get_SO2_subindex)

# Calculate AQI and AQI Bucket
def get_AQI(x):
    return max(x["PM2.5_SubIndex"], x["PM10_SubIndex"], x["SO2_SubIndex"])

def get_AQI_bucket(x):
    if x <= 50:
        return "Good"
    elif 50 < x <= 100:
        return "Satisfactory"
    elif 100 < x <= 200:
        return "Moderate"
    elif 200 < x <= 300:
        return "Poor"
    elif 300 < x <= 400:
        return "Very Poor"
    elif x > 400:
        return "Severe"
    else:
        return '0'

df["AQI"] = df.apply(get_AQI, axis=1)
df["AQI_Bucket"] = df["AQI"].apply(get_AQI_bucket)

# Select only numeric columns for correlation calculation
numeric_df = df.select_dtypes(include=np.number)

# Plot correlation heatmap
plt.figure(figsize=(12, 10))
sns.heatmap(numeric_df.corr(), cmap='coolwarm', annot=True)
plt.show()


# Plot pollutants distribution
pollutants = ['PM2.5', 'PM10', 'NOx', 'NO2', 'NOx', 'NH3', 'CO', 'SO2', 'O3', 'Benzene', 'Toluene', 'Xylene']
df[pollutants].plot(kind='line', figsize=(18, 18), cmap='coolwarm', subplots=True, fontsize=10)
plt.show()

# Plot average AQI
df[['City', 'AQI']].groupby('City').mean().sort_values('AQI').plot(kind='bar', cmap='Blues_r', figsize=(8, 8))
plt.title('Average AQI in last 5 years')
plt.show()

# Prepare data for model
final_df = df[['AQI', 'AQI_Bucket']].copy()
final_df['AQI_Bucket'] = final_df['AQI_Bucket'].map({'Good': 0, 'Satisfactory': 1, 'Moderate': 2, 'Poor': 3, 'Very Poor': 4, 'Severe': 5})

# Split data
X = final_df[['AQI']]
y = final_df[['AQI_Bucket']]
X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=0)

# K-Nearest Neighbors (KNN) Classifier
knn_classifier = KNeighborsClassifier(n_neighbors=5)
knn_classifier.fit(X_train, y_train)
knn_y_pred = knn_classifier.predict(X_test)

# Evaluate KNN model
print("KNN Classifier:")
print("Accuracy:", accuracy_score(y_test, knn_y_pred))
print(classification_report(y_test, knn_y_pred))
print(confusion_matrix(y_test, knn_y_pred))

# Gradient Boosting Machine (GBM) Classifier
gbm_classifier = GradientBoostingClassifier(random_state=0)
gbm_classifier.fit(X_train, y_train)
gbm_y_pred = gbm_classifier.predict(X_test)

# Evaluate GBM model
print("\nGradient Boosting Machine Classifier:")
print("Accuracy:", accuracy_score(y_test, gbm_y_pred))
print(classification_report(y_test, gbm_y_pred))
print(confusion_matrix(y_test, gbm_y_pred))


# Take input for city and date
input_city = input("Enter the name of the city: ")

# Filter the dataset for the input city
city_data = df[df['City'] == input_city]

# Display the available dates for the selected city
print("Available dates for", input_city, "are:")
print(city_data['Date'].unique())

input_date = input("Enter the date (YYYY-MM-DD): ")

# Filter the data for the selected city and date
selected_data = city_data[city_data['Date'] == input_date]

# Check if data exists for the selected city and date
if selected_data.empty:
    print("No data available for the specified city and date.")
else:
    # Calculate AQI
    AQI_input = selected_data.apply(get_AQI, axis=1).values[0]
    # Plot the values
    pollutants = ['PM2.5', 'PM10', 'NO', 'NO2', 'NOx', 'NH3', 'CO', 'SO2', 'O3', 'Benzene', 'Toluene', 'Xylene']
    selected_data[pollutants].plot(kind='bar', figsize=(12, 8))
    plt.title(f'Pollutant Values for {input_city} on {input_date}')
    plt.xlabel('Pollutant')
    plt.ylabel('Value')
    plt.xticks(rotation=45)
    plt.legend(title='Pollutant')
    plt.tight_layout()
    plt.show()

    # Make prediction
    predicted_AQI_bucket = gbm_classifier.predict([[AQI_input]])

    # Map the numerical label to AQI bucket category
    aqi_bucket_mapping = {0: 'Good', 1: 'Satisfactory', 2: 'Moderate', 3: 'Poor', 4: 'Very Poor', 5: 'Severe'}
    predicted_category = aqi_bucket_mapping[predicted_AQI_bucket[0]]

    print("Predicted AQI Value for City '{}' on Date '{}': {}".format(input_city, input_date, AQI_input))
    print("Predicted AQI Bucket for City '{}' on Date '{}': {}".format(input_city, input_date, predicted_category))
# Calculate the average values of pollutants
avg_values = selected_data[['PM2.5', 'PM10', 'NO', 'NO2', 'NOx', 'NH3', 'CO', 'SO2', 'O3', 'Benzene', 'Toluene', 'Xylene']].mean()

# Find the pollutant with the highest value exceeding its average
max_pollutant = avg_values.idxmax()
max_pollutant_value = selected_data[max_pollutant].values[0]

# Determine the reason based on the pollutant with the highest value
reason = ""
if max_pollutant == 'PM2.5':
    reason = "Vehicle emissions, industrial processes, construction activities, and natural sources like wildfires and dust storms"
elif max_pollutant == 'PM10':
    reason = "Vehicle emissions, industrial processes, and construction activities"
elif max_pollutant == 'NO':
    reason = "Vehicles and industrial facilities"
elif max_pollutant == 'NO2':
    reason = "Burning fossil fuels at high temperatures, such as in vehicles and power plants"
elif max_pollutant == 'NOx':
    reason = "Vehicles, power plants, and industrial facilities"
elif max_pollutant == 'NH3':
    reason = "Fertilizer application, livestock waste, and animal husbandry"
elif max_pollutant == 'CO':
    reason = "Vehicle exhaust, industrial processes, and wildfires"
elif max_pollutant == 'SO2':
    reason = "Coal and oil in power plants and industrial facilities"
elif max_pollutant == 'O3':
    reason = "NOx and volatile organic compounds"
elif max_pollutant == 'Benzene':
    reason = "Petroleum refining, chemical manufacturing"
elif max_pollutant == 'Toluene':
    reason = "Industrial processes, vehicle exhaust"
elif max_pollutant == 'Xylene':
    reason = "Industrial processes, vehicle exhaust"

# Print the reason for the highest pollutant value exceeding its average
print(f"The pollutant with the highest value exceeding its average is {max_pollutant} with a value of {max_pollutant_value}. The reason for the high concentration is: {reason}")